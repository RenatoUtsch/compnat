//
// Copyright 2017 Renato Utsch
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

namespace stats;
file_identifier "CNAT";
file_extension "cnat";

/// Stores an int value and standard deviation.
struct intStd {
  value: int;
  stddev: double;
};

/// Stores an uint value and standard deviation.
struct uintStd {
  value: uint;
  stddev: double;
};

/// Stores a double value and standard deviation.
struct doubleStd {
  value: double;
  stddev: double;
};

/// Parameters used during execution by all instances.
table Params {
  /// Global seed used to seed the instances.
  seed: uint;

  /// Number of generations.
  numGenerations: uint;

  /// Population size.
  populationSize: uint;

  /// Tournament size.
  tournamentSize: uint;

  /// Maximum tree height.
  maxHeight: uint;

  /// Max elements? Bloat factor?

  /// Crossover probability.
  crossoverProb: double;

  /// Mut prob?

  /// If using elitism.
  elitism: bool;

  /// Comma-separated list of functions.
  functions: string;
}

/// Results aggregated for a single generation and dataset.
table GenerationResults {
  /// Fitness of the best individual in the generation.
  bestFitness: doubleStd;

  /// Size of the best individual in the generation.
  bestSize: uintStd;

  /// Fitness of the worst individual in the generation.
  worstFitness: doubleStd;

  /// Size of the worst individual in the generation.
  worstSize: uintStd;

  /// Average fitness in the generation.
  avgFitness: doubleStd;

  /// Average individual size in the generation.
  avgSize: uintStd;

  /// Number of repeated individuals in the generation.
  numRepeated: uintStd;

  /// Number of individuals generated by crossover better than their parents.
  /// -1 if the data is not available.
  numCrossoverBetter: intStd = -1;

  /// Number of individuals generated by crossover worse than their parents.
  /// -1 if the data is not available.
  numCrossoverWorse: intStd = -1;

  /// Number of individuals generated by mutation better than their parents.
  /// -1 if the data is not available.
  numMutationBetter: intStd = -1;

  /// Number of individuals generated by mutation worse than their parents.
  /// -1 if the data is not available.
  numMutationWorse: intStd = -1;
}

/// All results of the given execution.
table GlobalResults {
  /// Parameters used during execution.
  params: Params;

  /// Aggregated results for each generation for the training dataset.
  trainResults: [GenerationResults];

  /// Aggregated results for each generation for the test dataset. This may
  /// or may not be available depending on the command-line flags.
  testResults: [GenerationResults];

  /// Aggregated results for the final generation for the test dataset.
  /// Data for better / worse individuals than their parents may not be
  /// generated if test results are not saved for each generation.
  finalResults: GenerationResults;
};

root_type GlobalResults;
