//
// Copyright 2017 Renato Utsch
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

namespace stats;
file_identifier "CNAT";
file_extension "cnat";

/// Stores an int value and standard deviation.
struct intStd {
  value: int;
  stddev: double;
}

/// Stores an uint value and standard deviation.
struct uintStd {
  value: uint;
  stddev: double;
}

/// Stores a double value and standard deviation.
struct doubleStd {
  value: double;
  stddev: double;
}

/// Parameters used during execution by all instances.
table GlobalParams {
  /// Global seed used to seed the instances.
  seed: uint;

  /// Number of instances.
  numInstances: uint;

  /// Number of generations.
  numGenerations: uint;

  /// Population size.
  populationSize: uint;

  /// Tournament size.
  tournamentSize: uint;

  /// Maximum tree height.
  maxHeight: uint;

  /// Crossover probability.
  crossoverProb: double;

  /// If using elitism.
  elitism: bool;

  /// Comma-separated list of functions.
  functions: string;
}

/// Statistics for one generation and dataset.
table GenerationStats {
  /// Fitness of the best individual in the generation.
  bestFitness: double;

  /// Size of the best individual in the generation.
  bestSize: uint;

  /// String of the best individual in the generation.
  bestStr: string;

  /// Fitness of the worst individual in the generation.
  worstFitness: double;

  /// Size of the worst individual in the generation.
  worstSize: uint;

  /// Average fitness in the generation.
  avgFitness: double;

  /// Average individual size in the generation.
  avgSize: uint;

  /// Number of repeated individuals in the generation.
  numRepeated: uint;

  /// Number of individuals generated by crossover better than their parents.
  /// -1 if the data is not available.
  numCrossBetter: int = -1;

  /// Number of individuals generated by crossover worse than their parents.
  /// -1 if the data is not available.
  numCrossWorse: int = -1;

  /// Number of individuals generated by mutation better than their parents.
  /// -1 if the data is not available.
  numMutBetter: int = -1;

  /// Number of individuals generated by mutation worse than their parents.
  /// -1 if the data is not available.
  numMutWorse: int = -1;
}

/// Results aggregated for all generations, aggregated for all instances.
table AggregatedStats {
  /// Fitness of the best individual in the generation.
  bestFitness: doubleStd;

  /// Size of the best individual in the generation.
  bestSize: uintStd;

  /// Best individual in the generation, across all instances.
  bestStr: string;

  /// Exact fitness of the best individual across all instances.
  bestStrFitness: double;

  /// Exact size of the best individual across all instances.
  bestStrSize: uint;

  /// Fitness of the worst individual in the generation.
  worstFitness: doubleStd;

  /// Size of the worst individual in the generation.
  worstSize: uintStd;

  /// Average fitness in the generation.
  avgFitness: doubleStd;

  /// Average individual size in the generation.
  avgSize: uintStd;

  /// Number of repeated individuals in the generation.
  numRepeated: uintStd;

  /// Number of individuals generated by crossover better than their parents.
  /// -1 if the data is not available.
  numCrossBetter: intStd;

  /// Number of individuals generated by crossover worse than their parents.
  /// -1 if the data is not available.
  numCrossWorse: intStd;

  /// Number of individuals generated by mutation better than their parents.
  /// -1 if the data is not available.
  numMutBetter: intStd;

  /// Number of individuals generated by mutation worse than their parents.
  /// -1 if the data is not available.
  numMutWorse: intStd;
}

/// All results for one instance.
table InstanceResults {
  /// Aggregated results for each generation for the training dataset.
  trainStats: [GenerationStats];

  /// Aggregated results for each generation for the test dataset. This may
  /// or may not be available depending on the command-line flags.
  testStats: [GenerationStats];

  /// Aggregated results for the final generation for the test dataset.
  finalStats: GenerationStats;
}

/// Aggregated results for all instances.
table AggregatedResults {
  /// Aggregated results for each generation for the training dataset.
  trainStats: [AggregatedStats];

  /// Aggregated results for each generation for the test dataset. This may
  /// or may not be available depending on the command-line flags.
  testStats: [AggregatedStats];

  /// Aggregated results for the final generation for the test dataset.
  finalStats: AggregatedStats;
}

/// All results of the given execution.
table GlobalResults {
  /// Parameters used during execution.
  params: GlobalParams;

  /// Results for each instance.
  instanceResults: [InstanceResults];

  /// Results aggregated for all instances.
  aggregatedResults: AggregatedResults;
}

root_type GlobalResults;
