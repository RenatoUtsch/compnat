//
// Copyright 2017 Renato Utsch
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

namespace stats.results;
file_identifier "CNAT";
file_extension "cnat";

/// Stores a double mean and standard deviation.
struct meanStddev {
  mean: double;
  stddev: double;
}

/// Parameters used during execution by all instances.
table Params {
  /// Global seed used to seed the instances.
  seed: uint;

  /// Number of instances.
  numInstances: uint;

  /// Number of generations.
  numGenerations: uint;

  /// Population size.
  populationSize: uint;

  /// Tournament size.
  tournamentSize: uint;

  /// Maximum tree height.
  maxHeight: uint;

  /// Crossover probability.
  crossoverProb: double;

  /// If using elitism.
  elitism: bool;

  /// If always testing on each generation.
  alwaysTest: bool;
}

/// Results aggregated for all generations, aggregated for all instances.
table AggregatedStats {
  /// Fitness of the best individual in the generation.
  bestFitness: meanStddev;

  /// Size of the best individual in the generation.
  bestSize: meanStddev;

  /// Fitness of the worst individual in the generation.
  worstFitness: meanStddev;

  /// Size of the worst individual in the generation.
  worstSize: meanStddev;

  /// Average fitness in the generation.
  avgFitness: meanStddev;

  /// Average individual size in the generation.
  avgSize: meanStddev;

  /// Number of repeated individuals in the generation.
  numRepeated: meanStddev;

  /// Number of individuals generated by crossover better than their parents.
  /// < 0 if the data is not available.
  numCrossBetter: meanStddev;

  /// Number of individuals generated by crossover worse than their parents.
  /// < 0 if the data is not available.
  numCrossWorse: meanStddev;

  /// Number of individuals generated by mutation better than their parents.
  /// < 0 if the data is not available.
  numMutBetter: meanStddev;

  /// Number of individuals generated by mutation worse than their parents.
  /// < 0 if the data is not available.
  numMutWorse: meanStddev;

  /// Best individual in the generation, across all instances.
  bestIndividualStr: string;

  /// Exact fitness of the best individual across all instances.
  bestIndividualFitness: double;

  /// Exact size of the best individual across all instances.
  bestIndividualSize: uint;
}

/// All results of the given execution.
table Results {
  /// Parameters used during execution.
  params: Params;

  /// Aggregated results for each generation for the training dataset.
  trainStats: [AggregatedStats];

  /// Aggregated results for each generation for the test dataset. This may
  /// or may not be available depending on the alwaysTest param.
  testStats: [AggregatedStats];

  /// Aggregated results for the final generation for the test dataset.
  finalStats: AggregatedStats;
}

root_type Results;
