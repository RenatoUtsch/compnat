/*
 * Copyright 2017 Renato Utsch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef COMPNAT_TP1_STATISTICS_HPP
#define COMPNAT_TP1_STATISTICS_HPP

#include <string>
#include <vector>

#include "representation.hpp"
#include "threading.hpp"

namespace stats {

/**
 * Calculates the fitness of an individual given a set of input data.
 * This is implemented as the Root-mean-square deviation.
 * @param individual The individual used when calculating the fitness.
 * @param size The size of the individual.
 * @param dataset Dataset to use to calculate the fitness.
 * @return A pair of the fitness and the RMSE.
 */
double fitness(const repr::Node &individual, const repr::Dataset &dataset);

/**
 * Calculates the fitness for all population and returns it in a vector.
 * This is implemented as the Root-mean-square deviation.
 * @param pool Thread pool.
 * @param population The population used when calculating the fitness.
 * @param sizes The size of each individual in the population.
 * @param dataset The dataset used to calculate the fitness.
 * @return Vector of fitness.
 */
std::vector<double> fitness(threading::ThreadPool &pool,
                            const std::vector<repr::Node> &population,
                            const repr::Dataset &dataset);

/**
 * Calculates the size for all the population.
 */
std::vector<size_t> sizes(const std::vector<repr::Node> &population);

/// Per-generation improvement stats.
struct ImprovementMetadata {
  /// Vector containing pair of individual index and average fitness of the
  /// parents for all individuals generated through crossover.
  std::vector<std::pair<size_t, double>> crossoverAvgParentFitness;

  /// Vector containing pair of individual index and fitness of the parent for
  /// all individuals generated through mutation.
  std::vector<std::pair<size_t, double>> mutationParentFitness;
};

/**
 * Stores the statistics of each generation.
 */
struct Statistics {
  /// Fitness of all individuals in the generation.
  std::vector<double> fitness;

  /// Sizes of all individuals in the generation.
  std::vector<size_t> sizes;

  /// Index of the best individual in the generation.
  size_t best;

  /// Index of the worst individual in the generation.
  size_t worst;

  /// Average fitness of the generation.
  double averageFitness;

  /// Average individual size.
  size_t averageSize;

  /// Number of repeated individuals in the generation.
  size_t numRepeatedIndividuals;

  /// Number of individuals generated by crossover better than their parents.
  size_t numCrossoverBetter;

  /// Number of individuals generated by crossover worse than their parents.
  size_t numCrossoverWorse;

  /// Number of individuals generated by mutation better than their parent.
  size_t numMutationBetter;

  /// Number of individuals generated by mutation worse than their parent.
  size_t numMutationWorse;

  /// String representation of the best individual.
  std::string bestStr;

  Statistics(threading::ThreadPool &pool,
             const std::vector<repr::Node> &population,
             const repr::Dataset &dataset,
             const ImprovementMetadata &metadata = {});

private:
  /// best, worst, averageFitness.
  void calcFitnessStats_();

  /// numRepeatedIndividuals.
  void calcRepeatedIndividuals_();

  void calcAverageSize_();

  // num[Crossover/Mutation]Better, num[Crossover/Mutation]Worse.
  void calcImprovementStats_(const ImprovementMetadata &metadata);

  void calcFitnessImprovement_(
      const std::vector<std::pair<size_t, double>> &fitnesses, size_t &better,
      size_t &worse);

  void printStats_(const ImprovementMetadata &metadata);
};

/* /// Generation results created by aggregating all instance's statistics. */
/* GenerationResults */
/* generationResults(const std::vector<Statistics> &allStatistics); */

} // namespace stats

#endif // !COMPNAT_TP1_STATISTICS_HPP
